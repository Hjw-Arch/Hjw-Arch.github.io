---
title: X86--开机加电到main函数之前
date: 2024-12-03 13:00:00 +0800
categories: [操作系统, X86]
tags: [操作系统]
---

## 启动BIOS，准备实模式下的中断向量表和中断服务程序
现代的X86架构的机器在上电后会默认进入实模式（16位数据线、20位地址线，功能受限），这是为了兼容以前的程序。

操作系统存在于软盘\硬盘之上，因此上电时不能立即运行操作系统，而是需要进行引导，即将操作系统载入内存进行运行。因此还需要一个能够引导操作系统进入内存运行的程序。这个程序叫BIOS，是一段被固化的程序，不能修改，它的任务就是引导操作系统进入内存，同时需要做一些必要的正确性检查。

X86架构的机器会在上电时自动将CS:IP设置为0xFFFF0，即默认从内存地址0xFFFF0这个地方存放的指令开始运行，这个地址是BIOS程序的第一条指令，这条指令是一条无条件跳转指令，跳转到BIOS的开头。为什么要跳转而不是直接执行真正的BIOS程序？因为各个厂商的BIOS不一定一样大，有些可能1KB，有些可能2KB，如果放在内存的开头位置，那么用户程序有可能要从0x400开始运行也可能从0x800开始运行，不好控制，因此需要将BIOS程序放在内存的尾部，当然，由于BIOS不一样长，因此BIOS开始的地址不固定，就借用一条跳转指令跳转到BIOS的开始地址。你知道的，0xFFFF0这个地址离1M（20根地址线最大寻址地址）只有16个字节，也就能放一条指令。

### 设置中断向量表
BIOS代码开始执行，首先会在内存最开始的位置（0x00000）用1KB的内存空间构建中断向量表（256项，每项4字节，0x00000~0x003ff），然后在紧挨着的位置使用256字节的空间构建BIOS的数据区（0x00400~0x004ff），然后在大概57KB以后（0x0E05B~0x0FFFE）的位置加载了8KB左右的与中断向量表配套的中断服务程序的代码。

## 加载操作系统内核程序，为保护模式做准备
### 加载bootsec程序
接下来BIOS的任务就是加载操作系统进入内存了。

首先，BIOS会使用int 0x19指令，即调用0x19号中断，CPU会根据中断向量表找到0x19号中断处理程序的入口地址，将CS:IP设置为此地址，这个中断处理程序的功能就是将磁盘的第零磁道第一扇区中大小为512字节的内容（bootsec程序，也叫MBR）加载到内存的指定位置中（0x07c00），并将CS:IP设置到这个地址。当然，实际上BIOS也会做一些检查，它要求这512字节的最后两个字节是0x55和0xaa这两个魔数。注意，目前来说中断程序是BIOS自带的，跟操作系统无关。

> 为什么是**0x7C00** 这个地址？  
实际上这是CPU厂商与操作系统软件的一种约定，也是个历史问题。当时8088芯片搭配的操作系统是86-DOS，这个操作系统需要的内存最小是32KB（0x0000~0x7FFF），此前已经介绍了，内存开始的1KB个字节要放中断向量表，BIOS数据紧随其后，为了将更多的内存空间留给用户，因此就将bootsec程序放在内存的最后1KB的位置（程序占512B，程序产生的数据存放与紧贴着的512B），那么bootsec的位置就应该放在32KB-1KB，即0x7c00这个位置了。当然，也是为了方便后续再次利用这段内存，bootsec程序放在前面的话，后续加载别的程序就需要在此之后存放，那么bootsec占用的这段内存就不容易再次被利用，需要考虑的麻烦一点，因此干脆放最后，用起来需要考虑的就少了。
{: .prompt-info }

这段被加载到内存0x07c00位置的程序也就是bootsec程序了，这是操作系统自己的代码。它的任务同BIOS类似，就是把操作系统后续的代码加载到内存。（为什么不用BIOS做？BIOS是固化的程序，不适合太大，而且不同操作系统的引导程序也不一样，让操作系统自己来加载显然更灵活）
```text
为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载?为什么BIOS没有直接把所有需要加载的扇区都加载?

标准化与兼容性：通过定义一个标准，即所有可启动介质的第一个扇区都包含有引导代码，这样可以确保不同制造商生产的硬件和软件之间的兼容性。这种做法简化了启动过程的设计，并且使得不同的存储设备能够以一致的方式被处理。

技术限制：早期的个人电脑硬件资源十分有限，包括内存大小以及处理器速度。直接加载整个操作系统或大量数据到内存中可能超出了当时硬件的能力。因此，采用分阶段加载的方法是一种更实际的选择。

灵活性：通过让第一个扇区内的引导代码来决定如何加载后续部分，可以提供更大的灵活性。例如，不同的操作系统可能需要以不同的方式被加载；或者，用户可能希望选择从多个安装在单一磁盘上的操作系统之一启动。这样的设计允许每个操作系统的引导加载器自行决定接下来要做什么。
```

### 加载setup程序

#### 内存规划
现在BIOS已经将bootsec程序加载到内存了，理所当然的要执行这段程序。bootsec的任务就是将第二批、第三批操作系统代码加载到内存。

由于当前操作系统主要使用的是汇编语言，没有编译器等工具来自动规划内存，当然这种对内存布局定制化程度比较高的程序编译器也做不了。总而言之内存规划需要自己操作，因此bootsec首先做的就是规划内存布局。
```text
SETUPLEN = 4        ;setup程序所占的磁盘的扇区数量
BOOTSEG = 0x07c0    ;bootsec程序的位置
INITSEG = 0x9000    ;bootsec程序将被移动的位置
SETUPSEF= 0x9020    ;setup程序开始的位置
SYSSEG  = 0x1000    ;system加载的位置
ENDSEG  = SYSSEG + SYSSIZE  ;加载结束的位置
ROOT_DEV= 0x306     ;根文件系统设备号
```



#### 复制自身

接下来bootsec做的动作就比较匪夷所思了：他将自身的代码（全部的512字节）复制到了内存的0x90000（INITSEG）这个位置。

```text
start:
    mov     ax, #BOOTSEG
    mov     ds, ax
    mov     ax, #INITSEG
    mov     es, ax
    mov     cx, #256
    sub     si, si
    sub     di, di
    rep
    movw
```

这次复制，ds与si，es与di联合使用，ds(0x7c0), si(0x0000)和es(0x9000), di(0x0000)构成了源地址0x07c00和目标地址0x90000，每次从ds:si指向的内存取两个字节的数据复制到es:di指向的内存地址，共复制256次，即512个字节。

#### 设置寄存器

复制完自身后，bootsec执行一个无条件跳转指令到0x90000段中bootsec应该执行的下一条指令，在新的位置继续执行bootsec剩下的代码。它做的工作为：
```text
mov     ax, cs
mov     ds, ax
mov     es, ax
mov     ss, ax
mov     sp, #0xff00     ;ss:sp组成栈指针，因此这两条指令将栈指针指向0x9ff00，设置了栈空间
```

#### 加载setup

加载setup程序依赖BIOS提供的0x13号中断程序。与0x19号中断程序不同，0x13号中断服务程序可以接受外部参数，能够根据调用者的意图来执行程序。因此调用次中断之前需要先将参数存放在约定的寄存器中：

```text
load_setup:
    mov         ds, #0x0000     ; drive 0, head 0
    mov         cx, #0x0002     ; sector 2, track 0
    mov         bx, #0x0200     ; address = 512, in INITSEG
    mov         ax, #0x0200 + SETUPLEN      ; service 2, nr of INITSEG
    int         0x13            ; 
    jnc         ok_load_setup   ; ok-continue
    mov         dx, #0x0000
    mov         ax, #0x0000     ; reset the diskette
    int         0x13            
    j           load_setup
```

这段程序将磁盘第二个扇区开始的4个扇区加载到0x90200这个位置（紧贴着bootsec），此时SS:SP指向的位置为0x9ff00，与0x90200还有很大的距离，因此存数据是足够的。

### 加载system模块

现在第二批代码（setup）已经加载入内存，需要加载第三批代码，即system，仍然使用BIOS提供的0x13号中断，且与加载setup流程基本相同。但本次加载的扇区数是240个，是之前4个扇区的60倍之多。因此需要的时间也要久很多。为了避免用户误会，此时Linux甚至会在屏幕上显示**Loading system...**，这也是通过BIOS提供的代码实现的。

本次加载将磁盘第六个扇区开始的约240个扇区加载到内存的SYSSEG（0x10000）处往后的120KB空间中。

至此，整个操作系统的代码已经被加载到了内存中，bootsec的主体工作也做完了，剩下的一件事就是确认一下根设备号，确认计算机中实际安装的软盘驱动器为根设备，并将信息写入机器系统数据。代码就不介绍了，意义不大。到此为止bootsec的任务就全部完成了，因此下面的一条指令就是跳到setup程序所在地址（0x90200），去执行setup程序。

### setup开始执行

setup程序开始做的第一件事就是利用BIOS提供的中断服务程序从设备上提取内核运行所需的**机器系统**数据，包括**光标位置**、**显示页面**等数据，并分别从中断向量0x41、0x46所指向的地址处获取硬盘参数表1、硬盘参数表2，把他们存放在0x9000:0x0080和0x9000:0x0090处。这些机器系统数据被保存在内存的0x90000~0x901FC位置（此前bootsec程序的位置，过河拆桥），它们在以后main函数执行时要发挥重要作用。

到此为止，操作系统的内核程序加载工作已经完成了。下面将实现从实模式到保护模式的切换！

## 开始向32位模式转变，为main函数的调用做准备
在这里，操作系统执行的操作主要是打开32位寻址空间、打开保护模式、建立保护模式下的中断响应机制等与保护模式配套的相关工作，建立内存的分页机制，最好做好调用main函数的准备。

### 关中断、移动system至内存起始位置

首先，setup程序将CPU的标志寄存器（EFLAGS）中的中断允许标志（IF）置0，也就是禁用中断，直到main函数建立起了完善的保护模式下的中断服务体系。

> 为什么要关中断？ 
在进入保护模式的准备期间，操作系统将破坏原有的中断服务体系，这意味着如果这个阶段发生了中断，系统将发生无法预料的行为，死机是一定的，因此在建立新的中断服务体系之前绝对不能响应中断。
{: .prompt-info }

接下来setup程序又做了一个匪夷所思的操作，它将位于0x10000处的内核程序复制到了内存地址的起始位置（0x00000）处！回顾一下会发现，这个位置原本是BIOS建立的中断向量表及相关数据的位置！