---
title: X86_Linux_0.11--设备环境初始化及激活进程0
date: 2024-12-05 13:00:00 +0800
categories: [操作系统, X86]
tags: [操作系统]
---

这章从main函数开始介绍，main函数执行之前的流程已经全部讲完了。

> 本章讲的主要是设备初始化和激活进程0两个部分，实际上设备初始化的内容对于理解学习操作系统并不重要，一带而过即可。
{: .prompt-tip}

## 设置根设备、硬盘

内核首先初始化根设备和硬盘，使用bootsect中写入机器系统数据0x901FC的根设备（bootsect做的最后一件事）为软盘的信息，设置软盘为根设备，并用起自0x90080的32字节的机器系统数据的硬盘参数表设置内核中的硬盘信息drive_info。代码就不介绍了，没啥意义，总之就是利用之前bootsec和setup程序留下的信息，初始化根设备和硬盘，学操作系统不需要在这个地方浪费时间。

## 规划物理内存格局，设置缓冲区、虚拟盘、主内存

接下来内核要设置缓冲区、虚拟盘、主内存。

Linus是这么规划的：除内核代码和数据所占的内存空间之外，其余的物理内存主要分为三个部分：**主内存区**、**缓冲区**和**虚拟盘**。**主内存区**是进程代码运行的空间，也包括内核管理进程的数据结构；**缓冲区**主要是作为主机与外设进行数据交换的中转站；**虚拟盘区**是一个可选的区域，如果使用虚拟盘，就可以讲外设上的数据先复制进虚拟盘区，然后加以使用（内存中操作数据的速度远高于外设，这样可以提高系统执行效率）。

```c
    //代码路径：init/main.c:
            …
    #define EXT_MEM_K (*(unsigned short *)0x90002)   //从1 MB开始的扩展内存（KB）数
            …
    void main(void)
    {
        …
        memory_end= (1<<20) + (EXT_MEM_K<<10); //1 MB + 扩展内存（MB）数，即内存总数
        memory_end &= 0xfffff000;    //按页的倍数取整，忽略内存末端不足一页的部分
        if (memory_end > 16*1024*1024)
            memory_end= 16*1024*1024;
        if (memory_end > 12*1024*1024)
            buffer_memory_end= 4*1024*1024;
        else if (memory_end > 6*1024*1024)
            buffer_memory_end= 2*1024*1024;
        else
            buffer_memory_end= 1*1024*1024;
        main_memory_start= buffer_memory_end;        //缓冲区之后就是主内存
            …
    }
```

内存格局的划分还要根据内存大小来设置，如果内存大小小于6MB，那么缓冲区的结束位置就是1MB，如果内存大小大于6MB小于12MB，那么缓冲区的结束位置在2MB，如果内存大小大于12MB，那么缓冲区结束位置在4MB。**主内存的起始位置就是缓冲区的结束位置**。

## 设置虚拟盘空间并初始化

《Linux内核设计的艺术》一书中提供的Linux源码是通过makefill文件中的一个标志位来配置是否使用虚拟盘的，本书默认使用2MB的虚拟盘。

虚拟盘的位置设置在缓冲区的末尾，也就是紧贴着缓冲区的2MB空间将被设置为虚拟盘，主内存的起始位置后移2MB的空间。代码就不看了，感兴趣可以自己阅读。

## 内存管理结构mem_map初始化

目前为止，主内存区和缓冲区的位置和大小已经确定了，于是系统开始调用`mem_init()`函数，先对主内存区的管理结构进行设置。

```c
//代码路径：init/main.c:
void main(void) {
    …
    mem_init(main_memory_start,memory_end);
    …
}

//代码路径：mm/memory.c:
…
#define LOW_MEM 0x100000                              //1 MB
#define PAGING_MEMORY (15*1024*1024)
#define PAGING_PAGES (PAGING_MEMORY>>12)             //15 MB的页数
#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)
#define USED 100
…
static long HIGH_MEMORY= 0;
…
static unsigned char mem_map [PAGING_PAGES]= {0,};
…
void mem_init(long start_mem, long end_mem) {
    int i;
    HIGH_MEMORY= end_mem;
    for (i=0;i<PAGING_PAGES;i++)
        mem_map[i]= USED;
        i= MAP_NR(start_mem);                        //start_mem为6 MB(虚拟盘之后)
        end_mem -= start_mem;
        end_mem >>= 12;                                      //16 MB的页数

        while (end_mem-->0)
            mem_map[i++]=0;
}
```

这段代码将1MB以上的分页进行管理，记录页面的使用次数，将缓冲区和虚拟盘（1MB~6MB）对应的`mem_map`标记为已使用，将主内存区标记为未使用。

> 为什么1MB以内的内存区域不进行这种管理？
这是因为设计者需要让内核和用户程序使用了两种不同的内存管理方式。内核使用分页管理方法，线性地址就等于物理地址，也就是内核可以直接获得物理地址。而用户程序不允许这样做，对于用户进程，线性地址和物理地址的差别非常大，没有可以递推的关系，因此用户进程也就推算不到真正的物理地址，也就无法访问内核了，当然也访问不了其它用户进程，但是内核由于一一映射的线性地址因此可以直接访问所有物理内存。1MB以上的内存空间都是留给用户使用的，因此采用上述这种专门的分页管理办法，而对内核当然不能这么用。
{: .prompt-tip}

## 异常处理类中断服务程序挂接

之前的setup程序破坏了BIOS建立的中断服务体系，head程序虽然建立了IDT，但所有的中断向量都指向了同一个中断服务程序。因此，内核为了能够响应异常和中断，现在需要重新建立异常处理以及中断服务体系（不需要区分异常和中断）。

```c
//代码路径：init/main.c:
void main(void) {
…
    trap_init();
…
}

//代码路径：kernel/traps.c:
void trap_init(void) {
    int i;
    set_trap_gate(0,&divide_error);//除零错误
    set_trap_gate(1,&debug);      //单步调试
    set_trap_gate(2,&nmi);        //不可屏蔽中断
    set_system_gate(3,&int3);     /* int3-5 can be called from all */
    set_system_gate(4,&overflow); //溢出
    set_system_gate(5,&bounds);  //边界检查错误
    set_trap_gate(6,&invalid_op); //无效指令
    set_trap_gate(7,&device_not_available);          //无效设备
    set_trap_gate(8,&double_fault);                //双故障
    set_trap_gate(9,&coprocessor_segment_overrun);//协处理器段越界
    set_trap_gate(10,&invalid_TSS);                //无效TSS
    set_trap_gate(11,&segment_not_present);         //段不存在
    set_trap_gate(12,&stack_segment);              //栈异常
    set_trap_gate(13,&general_protection);         //一般性保护异常
    set_trap_gate(14,&page_fault);                 //缺页
    set_trap_gate(15,&reserved);                   //保留
    set_trap_gate(16,&coprocessor_error);          //协处理器错误

    for (i=17;i<48;i++)                           //都先挂接好，中断服务程序函数名初
        set_trap_gate(i,&reserved);               //始化为保留                                               
        set_trap_gate(45,&irq13);                      //协处理器
        outb_p(inb_p(0x21)&0xfb,0x21);                 //允许IRQ2中断请求
        outb(inb_p(0xA1)&0xdf,0xA1);                   // 允许IRQ3中断请求
        set_trap_gate(39,&parallel_interrupt);         //并口
}
    
//代码路径：include\asm\system.h:
    …
#define _set_gate(gate_addr,type,dpl,addr)  \
__asm__("movw %%dx,%%ax\n\t" \                     //将edx的低字赋值给eax的低字
        "movw %0,%%dx\n\t" \                      //%0对应第二个冒号后的第1行的"i"
        "movl %%eax,%1\n\t" \                     //%1对应第二个冒号后的第2行的"o"
        "movl %%edx,%2" \                         //%2对应第二个冒号后的第3行的"o"
        : \                                      //这个冒号后面是输出，下面冒号后面
                                                            //是输入
        : "i" ((short) (0x8000 + (dpl<<13) + (type<<8))), \ //立即数
        "o" (*((char *) (gate_addr))), \             //中断描述符前4个字节的地址
        "o" (*(4 + (char *) (gate_addr))), \         //中断描述符后4个字节的地址
        "d" ((char *) (addr)),"a" (0x00080000))      //"d"对应edx，"a"对应eax
            …
#define set_trap_gate(n,addr) \
        _set_gate(&idt[n],15,0,addr)
```

看着真麻烦，主要就是设置中断向量对应的中断服务程序（设置IDT），设置了中断号0~16、17~47，并设置允许IRQ2和IRQ3中断，细节就自己扣吧。

## 初始化块设备请求项结构

Linux 0.11将外设分为**块设备**、**字符设备**两类。具体请你RTFW。硬盘、软盘等属于块设备，tty属于字符设备。

进程想要和块设备进行通信就必须经过主机内存中的缓冲区。之前提到的`request[32]`就是操作系统管理缓冲区中缓冲块与块设备上逻辑块之间读写关系的数据结构。

```c
//代码路径：init/main.c:
void main(void)
{
 …
blk_dev_init();
 …
}

//代码路径：kernel/blk_dev/blk.h:
 …
#define NR_REQUEST 32
struct request {
    int dev;       /* -1 if no request */
    int cmd;       /* READ or WRITE */
    int errors;
    unsigned long sector;
    unsigned long nr_sectors;
    char * buffer;
    struct task_struct * waiting;
    struct buffer_head * bh;
    struct request * next;        //说明request可以构成链表
};
 …
//代码路径：kernel/blk_dev/ll_rw_block.c:
 …
struct request request[NR_REQUEST];      //数组链表
    …
void blk_dev_init(void)
{
    int i;
    for (i=0;i<NR_REQUEST;i++) {
        request[i].dev= -1;             //设置为空闲
        request[i].next= NULL;          //互不挂接
    }
}

```

request[32]是一个由数组构成的链表；request[i].dev = −1说明了这个请求项还没有具体对应哪个设备，这个标志将来会被用来判断对应该请求项的当前设备是否空闲；request[i]. next =NULL说明这时还没有形成请求项队列。

## 与建立人机交互界面相关的外设的中断服务程序挂接

这里主要就是对tty设备进行初始化。tty设备，简单理解就是串口、键盘、显示器等人机交互设备。

### 对串口进行初始化

```c
//代码路径：kernel/chr_dev/serial.c:
void rs_init(void)
{
    set_intr_gate(0x24,rs1_interrupt);   //设置串行口1中断，参看2.5
    set_intr_gate(0x23,rs2_interrupt);   //设置串行口2中断
    init(tty_table[1].read_q.data);      //初始化串行口1
    init(tty_table[2].read_q.data);      //初始化串行口2
    outb(inb_p(0x21)&0xE7,0x21);         //允许IRQ3，IRQ4
}
```
两个串行口中断处理程序与IDT的挂接函数set_intr_gate()与之前介绍过的set_trap_gate()函数类似，可参看前面对set_trap_gate()函数的讲解。它们的差别是set_trap_gate()函数的type是15（二进制的1111，代表异常）​，而set_intr_gate()的type是14（二进制的1110，代表中断）​。

这没啥好说的，就把两个串口对应的IDT的中断服务程序字段设置一下，然后初始化串口，不必深究，这都不是重点。

### 设置显示器

这里要根据机器系统数据提供的显卡是“单色”还是“彩色”来设置配套信息。Linux0.11那么古老，就当是单色的了。不介绍了没意思。

### 设置键盘

对键盘的设置是首先将键盘对应的IDT的中断服务程序字段填充对应的中断服务程序地址，然后取消8259A对键盘中断的屏蔽，允许IRQ1发送中断信号。不解释了，没意思。

## 设置开机启动时间

开机启动时间是大部分与时间相关的计算的基础。操作系统中的一些程序的运算需要时间参数，很多事务的处理也需要用到时间，比如文件修改的时间、文件最近访问的时间、i节点自身的修改时间等，这些都是基于开机启动时间推断出来的。

具体步骤是：主板上有一个RTC（或者类似的玩意），系统通过调用`time_init()`这个函数去获取数据，包括年月日时分秒等等，然后将他们整合一下就是了。不解释了。


## 初始化进程0

前面的都没啥意义，对学习操作系统没什么帮助，现在要介绍的就比较重要了。

进程0是Linux操作系统中运行的第一个进程，也是Linux操作系统父子进程创建机制的第一个父进程。

初始化进程0主要有三个方面的工作：
1. 系统初始化进程0。这包括将进程0和task_struct中的LDT、TSS和GDT相挂接，对GDT、task数组已经进程调度相关的寄存器进行初始化设置。




